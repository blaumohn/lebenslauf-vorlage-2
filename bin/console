#!/usr/bin/env php
<?php

use App\Captcha\CaptchaService;
use App\Config;
use App\Cv\CvDataNormalizer;
use App\Cv\CvRenderer;
use App\Cv\CvStorage;
use App\Cv\CvViewModelBuilder;
use App\Cv\RedactionService;
use App\Cv\CvValidator;
use App\Cv\LabelService;
use App\Security\TokenService;
use App\Storage\FileStorage;
use App\Templating\TwigFactory;

$config = require __DIR__ . '/../src/bootstrap.php';

$rootPath = $config->rootPath();
$storage = new FileStorage();
$twig = TwigFactory::create($rootPath . '/templates');

$cvStorage = new CvStorage($storage, $rootPath . '/var/cache/html');
$renderer = new CvRenderer($twig);
$redactor = new RedactionService();
$viewBuilder = new CvViewModelBuilder();
$validator = new CvValidator($rootPath . '/schemas/lebenslauf.schema.json');
$langSetting = (string) $config->get('APP_LANGS', '');
$defaultLang = (string) $config->get('APP_LANG', 'de');
$labelsPath = (string) $config->get('LABELS_PATH', $rootPath . '/labels/etiketten.json');
$tokenService = new TokenService($storage, $rootPath . '/var/state/tokens');
$captchaService = new CaptchaService(
    $storage,
    $rootPath . '/var/tmp/captcha',
    $config->getInt('CAPTCHA_TTL_SECONDS', 600)
);

$argv = $_SERVER['argv'] ?? [];
$command = $argv[1] ?? '';

if ($command === 'cv:upload') {
    $profile = $argv[2] ?? '';
    $jsonPath = $argv[3] ?? '';

    if ($profile === '' || $jsonPath === '') {
        fail("Usage: cv:upload <PROFILE> <JSON_PATH>");
    }

    $decoded = loadJsonData($jsonPath);
    validateSchema($validator, $decoded['raw']);

    $langs = parseLangs($langSetting, $defaultLang);
    $primaryLang = $langs[0] ?? $defaultLang;
    foreach ($langs as $lang) {
        $labels = LabelService::fromJsonFile($labelsPath, $lang)->all();
        $normalizer = new CvDataNormalizer($lang);
        $normalized = $normalizer->normalize($decoded['data']);
        $privateView = $viewBuilder->build($normalized);
        $privateHtml = $renderer->renderPrivate($privateView, $labels);
        $cvStorage->savePrivateHtmlForLang($profile, $privateHtml, $lang);
        if ($lang === $primaryLang) {
            $cvStorage->savePrivateHtml($profile, $privateHtml);
        }

        renderPublicCvIfDefault(
            $config,
            $profile,
            $lang,
            $primaryLang,
            $normalized,
            $labels,
            $redactor,
            $viewBuilder,
            $renderer,
            $cvStorage
        );

        fwrite(STDOUT, "Private CV rendered for profile {$profile} ({$lang}).\n");
    }

    exit(0);
}

if ($command === 'token:rotate') {
    $profile = $argv[2] ?? '';
    $count = isset($argv[3]) ? (int) $argv[3] : 1;
    if ($profile === '') {
        fail("Usage: token:rotate <PROFILE> [COUNT]");
    }

    $count = max(1, $count);
    $tokens = $tokenService->generateTokens($count);
    $tokenService->rotate($profile, $tokens);

    fwrite(STDOUT, "New tokens for {$profile}:\n");
    foreach ($tokens as $token) {
        fwrite(STDOUT, $token . "\n");
    }
    exit(0);
}

if ($command === 'captcha:cleanup') {
    $deleted = $captchaService->cleanupExpired();
    fwrite(STDOUT, "Deleted {$deleted} expired CAPTCHA files.\n");
    exit(0);
}

fail("Commands:\n  cv:upload <PROFILE> <JSON_PATH>\n  token:rotate <PROFILE> [COUNT]\n  captcha:cleanup");

function fail(string $message, int $code = 1): void
{
    fwrite(STDERR, $message . "\n");
    exit($code);
}

function loadJsonData(string $jsonPath): array
{
    if (!is_file($jsonPath)) {
        fail("JSON file not found: {$jsonPath}");
    }

    $content = file_get_contents($jsonPath);
    $rawData = json_decode((string) $content);
    $data = json_decode((string) $content, true);
    if (!is_array($data) || $rawData === null) {
        fail("Invalid JSON: {$jsonPath}");
    }

    return ['raw' => $rawData, 'data' => $data];
}

function validateSchema(CvValidator $validator, mixed $rawData): void
{
    $errors = $validator->validate($rawData);
    if (empty($errors)) {
        return;
    }

    fwrite(STDERR, "Schema validation failed:\n");
    foreach ($errors as $error) {
        fwrite(STDERR, "- {$error}\n");
    }
    exit(1);
}

function renderPublicCvIfDefault(
    Config $config,
    string $profile,
    string $lang,
    string $primaryLang,
    array $normalized,
    array $labels,
    RedactionService $redactor,
    CvViewModelBuilder $viewBuilder,
    CvRenderer $renderer,
    CvStorage $cvStorage
): void {
    if (!isDefaultProfile($config, $profile)) {
        return;
    }

    $publicData = $redactor->redact($normalized);
    $publicView = $viewBuilder->build($publicData);
    $publicHtml = $renderer->renderPublic($publicView, $labels);
    $cvStorage->savePublicHtmlForLang($publicHtml, $lang);
    if ($lang === $primaryLang) {
        $cvStorage->savePublicHtml($publicHtml);
    }
    fwrite(STDOUT, "Public CV rendered for profile {$profile} ({$lang}).\n");
}

function isDefaultProfile(Config $config, string $profile): bool
{
    $defaultProfile = (string) $config->get('DEFAULT_CV_PROFILE', 'DEFAULT');
    return strcasecmp($profile, $defaultProfile) === 0;
}

function parseLangs(string $setting, string $fallback): array
{
    $setting = trim($setting);
    if ($setting === '') {
        $fallback = trim($fallback);
        return $fallback === '' ? [] : [strtolower($fallback)];
    }

    $parts = preg_split('/\s*,\s*/', $setting);
    if ($parts === false) {
        return [];
    }

    $langs = [];
    foreach ($parts as $part) {
        $value = strtolower(trim($part));
        if ($value !== '') {
            $langs[] = $value;
        }
    }

    return array_values(array_unique($langs));
}
